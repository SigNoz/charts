# Global override values
global:
  image:
    # -- Overrides the Docker registry globally for all images
    registry: null
  # -- Overrides the storage class for all PVC with persistence enabled.
  storageClass: null

# -- SigNoz chart name override
nameOverride: ""

# -- SigNoz chart full name override
fullnameOverride: ""

# -- Kubernetes cluster domain used when Clickhouse installed in different namespace
clusterDomain: cluster.local

# Clickhouse default values
# For complete list of configurations, check `values.yaml` of `clickhouse` chart.
# @ignored
clickhouse:
  # -- Cloud service being deployed on (example: `aws`, `azure`, `gcp`, `hcloud`, `other`).
  # Based on the cloud, storage class for the persistent volume is selected.
  # When set to 'aws' or 'gcp', new expandible storage class is created.
  # When set to something else or not set, the default storage class (if any) from the k8s cluster is selected.
  cloud: other

  zookeeper:
    #
    # Please DO NOT override this value.
    # This chart installs Zookeeper separately.
    # Only if you know what you are doing, proceed with overriding.
    #

    # -- Whether to install zookeeper. If false, `clickhouse.externalZookeeper` must be set.
    enabled: true

  # -- Whether to install clickhouse. If false, `clickhouse.host` must be set
  enabled: true

  # -- Which namespace to install clickhouse and `clickhouse-operator` to (defaults to namespace chart is installed to)
  namespace: ""
  # -- Name override for clickhouse
  nameOverride: ""
  # -- Fullname override for clickhouse
  fullnameOverride: ""

  # -- Clickhouse cluster
  cluster: cluster
  # -- Clickhouse database (SigNoz Metrics)
  database: signoz_metrics
  # -- Clickhouse trace database (SigNoz Traces)
  traceDatabase: signoz_traces
  # -- Clickhouse user
  user: admin
  # -- Clickhouse password
  password: 27ff0399-0d3a-4bd8-919d-17c2181e6fb9

  # -- Clickhouse image
  image:
    # -- Clickhouse image registry to use.
    registry: docker.io
    # -- Clickhouse image repository to use.
    repository: clickhouse/clickhouse-server
    # -- Clickhouse image tag to use (example: `21.8`).
    # SigNoz is not always tested with latest version of ClickHouse.
    # Only if you know what you are doing, proceed with overriding.
    tag: 22.4.5-alpine
    # -- Clickhouse image pull policy.
    pullPolicy: IfNotPresent

  # Clickhouse service
  service:
    # -- Annotations to use by service associated to Clickhouse instance
    annotations: {}
    # -- Service Type: LoadBalancer (allows external access) or NodePort (more secure, no extra cost)
    type: ClusterIP
    # -- Clickhouse HTTP port
    httpPort: 8123
    # -- Clickhouse TCP port
    tcpPort: 9000

  # -- Whether to use TLS connection connecting to ClickHouse
  secure: false
  # -- Whether to verify TLS certificate on connection to ClickHouse
  verify: false
  # -- URL for zookeeper.
  externalZookeeper: {}
    # servers:
    # - host: signoz-signoz-zookeeper
    #   port: 2181

  # -- Toleration labels for clickhouse pod assignment
  tolerations: []
  # -- Affinity settings for clickhouse pod
  affinity: {}

  # -- Configure resource requests and limits. Update according to your own use
  # case as these values might be too low for a typical deployment.
  # ref: http://kubernetes.io/docs/user-guide/compute-resources/
  resources: {}
  #   requests:
  #     cpu: 1000m
  #     memory: 4Gi
  #   limits:
  #     cpu: 4000m
  #     memory: 16Gi

  # -- Security context for Clickhouse node
  securityContext:
    enabled: true
    runAsUser: 101
    runAsGroup: 101
    fsGroup: 101

  # -- If enabled, operator will prefer k8s nodes with tag `clickhouse:true`
  useNodeSelector: false

  # -- An allowlist of IP addresses or network masks the ClickHouse user is
  # allowed to access from. By default anything within a private network will be
  # allowed. This should suffice for most use case although to expose to other
  # networks you will need to update this setting.
  #
  # Refs:
  # - https://clickhouse.com/docs/en/operations/settings/settings-users/#user-namenetworks
  # - https://en.wikipedia.org/wiki/Reserved_IP_addresses#IPv4
  allowedNetworkIps:
    - "10.0.0.0/8"
    - "100.64.0.0/10"
    - "172.16.0.0/12"
    - "192.0.0.0/24"
    - "198.18.0.0/15"
    - "192.168.0.0/16"

  persistence:
    # -- Enable data persistence using PVC for ClickHouseDB data.
    enabled: true

    # -- Use a manually managed Persistent Volume and Claim.
    # If defined, PVC must be created manually before volume will be bound.
    #
    existingClaim: ""

    # -- Persistent Volume Storage Class to use.
    # If defined, `storageClassName: <storageClass>`.
    # If set to "-", `storageClassName: ""`, which disables dynamic provisioning
    # If undefined (the default) or set to `null`, no storageClassName spec is
    # set, choosing the default provisioner.
    #
    storageClass: null

    # -- Access Modes for persistent volume
    accessModes:
      - ReadWriteOnce

    # -- Persistent Volume size
    size: 20Gi

  # -- Clickhouse user profile configuration.
  # You can use this to override profile settings, for example `default/max_memory_usage: 40000000000`
  # For the full list of settings, see:
  # - https://clickhouse.com/docs/en/operations/settings/settings-profiles/
  # - https://clickhouse.com/docs/en/operations/settings/settings/
  #
  profiles: {}

  # -- Default user profile configuration for Clickhouse. !!! Please DO NOT override this !!!
  defaultProfiles:
    default/allow_experimental_window_functions: "1"
    default/allow_nondeterministic_mutations: "1"

  # -- Clickhouse cluster layout. (Experimental, use at own risk)
  # For a full list of options, see https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md
  # section on clusters and layouts.
  #
  layout:
    shardsCount: 1
    replicasCount: 1

  # -- ClickHouse settings configuration.
  # You can use this to override settings, for example `prometheus/port: 9363`
  # For the full list of settings, see:
  # - https://clickhouse.com/docs/en/operations/settings/settings/
  #
  settings:
    # Uncomment those lines if you want to enable the built-in Prometheus HTTP endpoint in ClickHouse.
    prometheus/endpoint: /metrics
    prometheus/port: 9363
    # prometheus/metrics: true
    # prometheus/events: true
    # prometheus/asynchronous_metrics: true

  # -- Default settings configuration for ClickHouse. !!! Please DO NOT override this !!!
  defaultSettings:
    format_schema_path: /etc/clickhouse-server/config.d/

  # -- ClickHouse pod(s) annotation.
  podAnnotations:
    signoz.io/scrape: 'true'
    signoz.io/port: '9363'
    signoz.io/path: /metrics

  # Cold storage configuration
  coldStorage:
    # -- Whether to enable S3 cold storage
    enabled: false
    # -- Reserve free space on default disk (in bytes)
    defaultKeepFreeSpaceBytes: "10485760"
    # -- AWS S3 endpoint
    endpoint: https://<bucket-name>.s3.amazonaws.com/data/
    # AWS role configuration - to use environment variables instead of passing access and secret keys
    role:
      # -- Whether to enable AWS IAM ARN role.
      enabled: false
      # -- Annotations to use by service account associated to Clickhouse instance
      annotations:
        # aws role arn
        eks.amazonaws.com/role-arn: arn:aws:iam::******:role/*****
    # -- AWS Access Key
    accessKey: <access_key_id>
    # -- AWS Secret Access Key
    secretAccess: <secret_access_key>

  ###
  ###
  ### ---- MISC ----
  ###
  ###

  # -- When the `installCustomStorageClass` is enabled with `cloud` set as `gcp` or `aws`,
  # it creates custom storage class with volume expansion permission.
  installCustomStorageClass: false

  ###
  ###
  ### ---- CLICKHOUSE OPERATOR ----
  ###
  ###
  clickhouseOperator:
    # -- name of the component
    name: operator

    # -- Version of the operator
    version: 0.19.1

    # -- Clickhouse Operator image
    image:
      # -- Clickhouse Operator image registry to use.
      registry: docker.io
      # -- Clickhouse Operator image repository to use.
      repository: altinity/clickhouse-operator
      # -- Clickhouse Operator image tag.
      tag: 0.19.1
      # -- Clickhouse Operator image pull policy.
      pullPolicy: IfNotPresent

    serviceAccount:
      # -- Specifies whether a service account should be created
      create: true
      # -- Annotations to add to the service account
      annotations: {}
      # -- The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name:

    # -- Clickhouse Operator pod(s) annotation.
    podAnnotations:
      signoz.io/port: '8888'
      signoz.io/scrape: 'true'

    # -- Clickhouse Operator node selector
    nodeSelector: {}

    # Clickhouse logging config
    logger:
      # -- Logging level. Acceptable values: trace, debug, information, warning, error.
      level: information
      # -- Size of the file. Applies to log and errorlog. Once the file reaches size,
      # ClickHouse archives and renames it, and creates a new log file in its place.
      size: 1000M
      # -- The number of archived log files that ClickHouse stores.
      count: 10
      # -- Whether to send log and errorlog to the console instead of file. To enable, set to 1 or true.
      console: 1

    # -- Metrics Exporter config.
    metricsExporter:
      # -- name of the component
      name: metrics-exporter

      # -- Metrics Exporter service
      service:
        # -- Annotations to use by service associated to Metrics Exporter
        annotations: {}
        # -- Service Type: LoadBalancer (allows external access) or NodePort (more secure, no extra cost)
        type: ClusterIP
        # -- Metrics Exporter port
        port: 8888

      # -- Metrics Exporter image
      image:
        # -- Metrics Exporter image registry to use.
        registry: docker.io
        # -- Metrics Exporter image repository to use.
        repository: altinity/metrics-exporter
        # -- Metrics Exporter image tag.
        tag: 0.19.1
        # -- Metrics Exporter image pull policy.
        pullPolicy: IfNotPresent


## External clickhouse configuration
## This is required when clickhouse.enabled is false
##
externalClickhouse:
  # -- Host of the external cluster.
  host:
  # -- Name of the external cluster to run DDL queries on.
  cluster: cluster
  # -- Database name for the external cluster
  database: signoz_metrics
  # -- Clickhouse trace database (SigNoz Traces)
  traceDatabase: signoz_traces
  # -- User name for the external cluster to connect to the external cluster as
  user: ""
  # -- Password for the cluster. Ignored if existingClickhouse.existingSecret is set
  password: ""
  # -- Name of an existing Kubernetes secret object containing the password
  existingSecret:
  # -- Name of the key pointing to the password in your Kubernetes secret
  existingSecretPasswordKey:
  # -- Whether to use TLS connection connecting to ClickHouse
  secure: false
  # -- Whether to verify TLS connection connecting to ClickHouse
  verify: false
  # -- HTTP port of Clickhouse
  httpPort: 8123
  # -- TCP port of Clickhouse
  tcpPort: 9000

# Default values for query-service
queryService:
  name: "query-service"
  replicaCount: 1
  image:
    registry: docker.io
    repository: signoz/query-service
    tag: 0.11.1
    pullPolicy: IfNotPresent
  imagePullSecrets: []
  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name:
  initContainers:
    init:
      enabled: true
      image:
        registry: docker.io
        repository: busybox
        tag: 1.35
        pullPolicy: IfNotPresent
      command:
        delay: 5
        endpoint: /ping
        waitMessage: "waiting for clickhouseDB"
        doneMessage: "clickhouse ready, starting query service now"
  configVars:
    storage: clickhouse
    # ClickHouse URL is set and applied internally.
    # Don't override unless you know what you are doing.
    # clickHouseUrl: tcp://my-release-clickhouse:9000/?database=signoz_traces&username=clickhouse_operator&password=clickhouse_operator_password
    goDebug: netdns=go
    telemetryEnabled: true
    deploymentType: kubernetes-helm

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  # Query-Service service
  service:
    # -- Annotations to use by service associated to Query-Service
    annotations: {}
    # -- Service Type: LoadBalancer (allows external access) or NodePort (more secure, no extra cost)
    type: ClusterIP
    # -- Query-Service HTTP port
    port: 8080
    # -- Query-Service Internal port
    internalPort: 8085

  ingress:
    # -- Enable ingress for Query-Service
    enabled: false
    # -- Ingress Class Name to be used to identify ingress controllers
    className: ""
    # -- Annotations to Query-Service Ingress
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
      # cert-manager.io/cluster-issuer: letsencrypt-prod
    # -- Query-Service Ingress Host names with their path details
    hosts:
      - host: query-service.domain.com
        paths:
          - path: /
            pathType: ImplementationSpecific
            port: 8080
    # -- Query-Service Ingress TLS
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - query-service.domain.com

  # -- Configure resource requests and limits. Update according to your own use
  # case as these values might be too low for a typical deployment.
  # ref: http://kubernetes.io/docs/user-guide/compute-resources/
  resources:
    requests:
      cpu: 100m
      memory: 100Mi
    # limits:
    #   cpu: 750m
    #   memory: 1000Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  persistence:
    # -- Enable data persistence using PVC for SQLiteDB data.
    enabled: true

    # -- Persistent Volume Storage Class to use.
    # If defined, `storageClassName: <storageClass>`.
    # If set to "-", `storageClassName: ""`, which disables dynamic provisioning
    # If undefined (the default) or set to `null`, no storageClassName spec is
    # set, choosing the default provisioner.
    #
    storageClass: null

    # -- Access Modes for persistent volume
    accessModes:
      - ReadWriteOnce

    # -- Persistent Volume size
    size: 1Gi


# Default values for frontend
frontend:
  name: "frontend"
  replicaCount: 1

  image:
    registry: docker.io
    repository: signoz/frontend
    tag: 0.11.1
    pullPolicy: IfNotPresent
  imagePullSecrets: []
  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name:

  initContainers:
    init:
      enabled: true
      image:
        registry: docker.io
        repository: busybox
        tag: 1.35
        pullPolicy: IfNotPresent
      command:
        delay: 5
        endpoint: /api/v1/version
        waitMessage: "waiting for query-service"
        doneMessage: "query-service ready, starting frontend now"

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 11
    targetCPUUtilizationPercentage: 50
    targetMemoryUtilizationPercentage: 50
    behavior: {}
      # scaleDown:
      #   stabilizationWindowSeconds: 300
      #  policies:
      #   - type: Pods
      #     value: 1
      #     periodSeconds: 180
      # scaleUp:
      #   stabilizationWindowSeconds: 300
      #   policies:
      #   - type: Pods
      #     value: 2
      #     periodSeconds: 60

    autoscalingTemplate: []
    keda:
      enabled: false
      pollingInterval: "30"   # check 30sec periodically for metrics data
      cooldownPeriod: "300"   # once the load decreased, it will wait for 5 min and downscale
      minReplicaCount: "1"    # should be >= replicaCount specified in values.yaml
      maxReplicaCount: "5"
      triggers:
        - type: memory
          metadata:
            type: Utilization
            value: "80"   # hpa make sure average Utilization <=80 by adding new pods
        - type: cpu
          metadata:
            type: Utilization
            value: "80"   # hpa make sure average Utlization <=80 by adding new pods

  configVars: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  # Frontend service
  service:
    # -- Annotations to use by service associated to Frontend
    annotations: {}
    # -- Service Type: LoadBalancer (allows external access) or NodePort (more secure, no extra cost)
    type: ClusterIP
    # -- Frontend HTTP port
    port: 3301

  ingress:
    # -- Enable ingress for Frontend
    enabled: false
    # -- Ingress Class Name to be used to identify ingress controllers
    className: ""
    # -- Annotations to Frontend Ingress
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
      # cert-manager.io/cluster-issuer: letsencrypt-prod
    # -- Frontend Ingress Host names with their path details
    hosts:
      - host: frontend.domain.com
        paths:
          - path: /
            pathType: ImplementationSpecific
            port: 3301
    # -- Frontend Ingress TLS
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - frontend.domain.com

  # -- Frontend Nginx extra configurations
  nginxExtraConfig: |
      client_max_body_size 24M;
      large_client_header_buffers 8 16k;

  # -- Configure resource requests and limits. Update according to your own use
  # case as these values might be too low for a typical deployment.
  # ref: http://kubernetes.io/docs/user-guide/compute-resources/
  resources:
    requests:
      cpu: 100m
      memory: 100Mi
    # limits:
    #   cpu: 200m
    #   memory: 200Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

# Default values for Alertmanager
alertmanager:
  name: "alertmanager"
  replicaCount: 1

  image:
    registry: docker.io
    repository: signoz/alertmanager
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: 0.23.0-0.2

  command: []
  extraArgs: {}

  imagePullSecrets: []

  # Alertmanager service
  service:
    # -- Annotations to use by service associated to Alertmanager
    annotations: {}
    # -- Service Type: LoadBalancer (allows external access) or NodePort (more secure, no extra cost)
    type: ClusterIP
    # -- Alertmanager HTTP port
    port: 9093
    # -- Set this to you want to force a specific nodePort. Must be use with service.type=NodePort
    nodePort: null

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name:

  initContainers:
    init:
      enabled: true
      image:
        registry: docker.io
        repository: busybox
        tag: 1.35
        pullPolicy: IfNotPresent
      command:
        delay: 5
        endpoint: /api/v1/version
        waitMessage: "waiting for query-service"
        doneMessage: "query-service ready, starting alertmanager now"

  podSecurityContext:
    fsGroup: 65534
  dnsConfig: {}
    # nameservers:
    #   - 1.2.3.4
    # searches:
    #   - ns1.svc.cluster-domain.example
    #   - my.dns.search.suffix
    # options:
    #   - name: ndots
    #     value: "2"
    #   - name: edns0
  securityContext:
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    runAsUser: 65534
    runAsNonRoot: true
    runAsGroup: 65534

  additionalPeers: []

  livenessProbe:
    httpGet:
      path: /
      port: http

  readinessProbe:
    httpGet:
      path: /
      port: http

  ingress:
    # -- Enable ingress for Alertmanager
    enabled: false
    # -- Ingress Class Name to be used to identify ingress controllers
    className: ""
    # -- Annotations to Alertmanager Ingress
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
      # cert-manager.io/cluster-issuer: letsencrypt-prod
    # -- Alertmanager Ingress Host names with their path details
    hosts:
      - host: alertmanager.domain.com
        paths:
          - path: /
            pathType: ImplementationSpecific
            port: 9093
    # -- Alertmanager Ingress TLS
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - alertmanager.domain.com

  # -- Configure resource requests and limits. Update according to your own use
  # case as these values might be too low for a typical deployment.
  # ref: http://kubernetes.io/docs/user-guide/compute-resources/
  resources:
    requests:
      cpu: 100m
      memory: 100Mi
    # limits:
    #   cpu: 200m
    #   memory: 200Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  statefulSet:
    annotations: {}

  podAnnotations: {}
  podLabels: {}

  # Ref: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
  podDisruptionBudget: {}
    # maxUnavailable: 1
    # minAvailable: 1

  persistence:
    # -- Enable data persistence using PVC for Alertmanager data.
    enabled: true

    # -- Persistent Volume Storage Class to use.
    # If defined, `storageClassName: <storageClass>`.
    # If set to "-", `storageClassName: ""`, which disables dynamic provisioning
    # If undefined (the default) or set to `null`, no storageClassName spec is
    # set, choosing the default provisioner.
    #
    storageClass: null

    # -- Access Modes for persistent volume
    accessModes:
      - ReadWriteOnce

    # -- Persistent Volume size
    size: 100Mi

  ## Using the config, alertmanager.yml file is created.
  ## We no longer need the config file as query services
  ## delivers the required config.
  # config:
  # global:
  #   resolve_timeout: 1m
  #   slack_api_url: 'https://hooks.slack.com/services/xxx'

  # templates:
  #   - '/etc/alertmanager/*.tmpl'

  # receivers:
  # - name: 'slack-notifications'
  #   slack_configs:
  #   - channel: '#alerts'
  #     send_resolved: true
  #     icon_url: https://avatars3.githubusercontent.com/u/3380462
  #     title: '{{ template "slack.title" . }}'
  #     text: '{{ template "slack.text" . }}'

  # route:
  #   receiver: 'slack-notifications'

  ## Templates are no longer needed as they are included
  ## from frontend placeholder while creating alert channels.
  # templates:
  #   title.tmpl: |-
  #       {{ define "slack.title" }}
  #       [{{ .Status | toUpper }}{{ if eq .Status "firing" }}:{{ .Alerts.Firing | len }}{{ end }}] {{ .CommonLabels.alertname }} for {{ .CommonLabels.job }}
  #       {{- if gt (len .CommonLabels) (len .GroupLabels) -}}
  #         {{" "}}(
  #         {{- with .CommonLabels.Remove .GroupLabels.Names }}
  #           {{- range $index, $label := .SortedPairs -}}
  #             {{ if $index }}, {{ end }}
  #             {{- $label.Name }}="{{ $label.Value -}}"
  #           {{- end }}
  #         {{- end -}}
  #         )
  #       {{- end }}
  #       {{ end }}
  #   text.tmpl: |-
  #       {{ define "slack.text" }}
  #       {{ range .Alerts -}}
  #       *Alert:* {{ .Labels.alertname }}{{ if .Labels.severity }} - `{{ .Labels.severity }}`{{ end }}

  #       *Summary:* {{ .Annotations.summary }}
  #       *Description:* {{ .Annotations.description }}

  #       *Details:*
  #         {{ range .Labels.SortedPairs }} • *{{ .Name }}:* `{{ .Value }}`
  #         {{ end }}
  #       {{ end }}
  #       {{ end }}

  ## Monitors ConfigMap changes and POSTs to a URL
  ## Ref: https://github.com/jimmidyson/configmap-reload
  ##
  configmapReload:
    ## If false, the configmap-reload container will not be deployed
    ##
    enabled: false

    ## configmap-reload container name
    ##
    name: configmap-reload

    ## configmap-reload container image
    ##
    image:
      repository: jimmidyson/configmap-reload
      tag: v0.5.0
      pullPolicy: IfNotPresent

    # containerPort: 9533

    # -- Configure resource requests and limits. Update according to your own use
    # case as these values might be too low for a typical deployment.
    # ref: http://kubernetes.io/docs/user-guide/compute-resources/
    resources: {}

# Default values for OtelCollector
otelCollector:
  name: "otel-collector"
  image:
    registry: docker.io
    repository: signoz/signoz-otel-collector
    tag: 0.55.1
    pullPolicy: Always
  imagePullSecrets: []

  # OpenTelemetry Collector executable
  command:
    # -- OtelCollector command name
    name: /signoz-collector
    # -- OtelCollector command extra arguments
    extraArgs: []

  configMap:
    # -- Specifies whether a configMap should be created (true by default)
    create: true

  # OtelCollector service
  service:
    # -- Annotations to use by service associated to OtelCollector
    annotations: {}
    # -- Service Type: LoadBalancer (allows external access) or NodePort (more secure, no extra cost)
    type: ClusterIP

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name:

  # -- OtelColector Deployment annotation.
  annotations: {}
  # -- OtelColector pod(s) annotation.
  podAnnotations:
    signoz.io/scrape: 'true'
    signoz.io/port: '8889'
    signoz.io/path: /metrics

  minReadySeconds: 5
  progressDeadlineSeconds: 120
  replicaCount: 1

  initContainers:
    init:
      enabled: true
      image:
        registry: docker.io
        repository: busybox
        tag: 1.35
        pullPolicy: IfNotPresent
      command:
        delay: 5
        endpoint: /ping
        waitMessage: "waiting for clickhouseDB"
        doneMessage: "clickhouse ready, starting otel collector now"

  # OtelCollector RBAC config
  clusterRole:
    # -- Specifies whether a clusterRole should be created
    create: false
    # -- Annotations to add to the clusterRole
    annotations: {}
    # -- The name of the clusterRole to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""
    # -- A set of rules as documented here.
    # ref: https://kubernetes.io/docs/reference/access-authn-authz/rbac/
    rules: []
      # - apiGroups: [""]
      #   resources: ["pods", "nodes"]
      #   verbs: ["get", "list", "watch"]

    # OtelCollector clusterRoleBinding
    clusterRoleBinding:
      # Annotations to add to the clusterRoleBinding
      annotations: {}
      # The name of the clusterRoleBinding to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""

  # Configuration for ports
  ports:
    otlp:
      # -- Whether to enable service port for OTLP gRPC
      enabled: true
      # -- Container port for OTLP gRPC
      containerPort: 4317
      # -- Service port for OTLP gRPC
      servicePort: 4317
      # -- Node port for OTLP gRPC
      nodePort: ""
      # -- Protocol to use for OTLP gRPC
      protocol: TCP
    otlp-http:
      # -- Whether to enable service port for OTLP HTTP
      enabled: true
      # -- Container port for OTLP HTTP
      containerPort: 4318
      # -- Service port for OTLP HTTP
      servicePort: 4318
      # -- Node port for OTLP HTTP
      nodePort: ""
      # -- Protocol to use for OTLP HTTP
      protocol: TCP
    jaeger-compact:
      # -- Whether to enable service port for Jaeger Compact
      enabled: false
      # -- Container port for Jaeger Compact
      containerPort: 6831
      # -- Service port for Jaeger Compact
      servicePort: 6831
      # -- Node port for Jaeger Compact
      nodePort: ""
      # -- Protocol to use for Jaeger Compact
      protocol: UDP
    jaeger-thrift:
      # -- Whether to enable service port for Jaeger Thrift HTTP
      enabled: true
      # -- Container port for Jaeger Thrift
      containerPort: 14268
      # -- Service port for Jaeger Thrift
      servicePort: 14268
      # -- Node port for Jaeger Thrift
      nodePort: ""
      # -- Protocol to use for Jaeger Thrift
      protocol: TCP
    jaeger-grpc:
      # -- Whether to enable service port for Jaeger gRPC
      enabled: true
      # -- Container port for Jaeger gRPC
      containerPort: 14250
      # -- Service port for Jaeger gRPC
      servicePort: 14250
      # -- Node port for Jaeger gRPC
      nodePort: ""
      # -- Protocol to use for Jaeger gRPC
      protocol: TCP
    zipkin:
      # -- Whether to enable service port for Zipkin
      enabled: false
      # -- Container port for Zipkin
      containerPort: 9411
      # -- Service port for Zipkin
      servicePort: 9411
      # -- Node port for Zipkin
      nodePort: ""
      # -- Protocol to use for Zipkin
      protocol: TCP
    prometheus-metrics:
      # -- Whether to enable service port for SigNoz exported prometheus metrics
      enabled: false
      # -- Container port for SigNoz exported prometheus metrics
      containerPort: 8889
      # -- Service port for SigNoz exported prometheus metrics
      servicePort: 8889
      # -- Node port for SigNoz exported prometheus metrics
      nodePort: ""
      # -- Protocol to use for SigNoz exported prometheus metrics
      protocol: TCP
    metrics:
      # -- Whether to enable service port for internal metrics
      enabled: true
      # -- Container port for internal metrics
      containerPort: 8888
      # -- Service port for internal metrics
      servicePort: 8888
      # -- Node port for internal metrics
      nodePort: ""
      # -- Protocol to use for internal metrics
      protocol: TCP
    zpages:
      # -- Whether to enable service port for ZPages
      enabled: false
      # -- Container port for Zpages
      containerPort: 55679
      # -- Service port for Zpages
      servicePort: 55679
      # -- Node port for Zpages
      nodePort: ""
      # -- Protocol to use for Zpages
      protocol: TCP

  # -- Configure liveness and readiness probes.
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes
  livenessProbe:
    enabled: false
    port: 13133
    path: /
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 6
    successThreshold: 1
  readinessProbe:
    enabled: false
    port: 13133
    path: /
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 6
    successThreshold: 1

  # -- Custom liveness probe
  customLivenessProbe: {}
  # -- Custom readiness probe
  customReadinessProbe: {}

  ingress:
    # -- Enable ingress for OtelCollector
    enabled: false
    # -- Ingress Class Name to be used to identify ingress controllers
    className: ""
    # -- Annotations to OtelCollector Ingress
    annotations: {}
      # cert-manager.io/cluster-issuer: letsencrypt-prod
      # nginx.ingress.kubernetes.io/ssl-redirect: "true"
      # nginx.ingress.kubernetes.io/backend-protocol: "GRPC"
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    # -- OtelCollector Ingress Host names with their path details
    hosts:
      - host: otelcollector.domain.com
        paths:
          - path: /
            pathType: ImplementationSpecific
            port: 4318
    # -- OtelCollector Ingress TLS
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - otelcollector.domain.com

  # -- Configure resource requests and limits. Update according to your own use
  # case as these values might be too low for a typical deployment.
  # ref: http://kubernetes.io/docs/user-guide/compute-resources/
  resources:
    requests:
      cpu: 100m
      memory: 100Mi
    # limits:
    #   cpu: 1000m
    #   memory: 2Gi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 11
    targetCPUUtilizationPercentage: 50
    targetMemoryUtilizationPercentage: 50
    behavior: {}
      # scaleDown:
      #   stabilizationWindowSeconds: 300
      #  policies:
      #   - type: Pods
      #     value: 1
      #     periodSeconds: 180
      # scaleUp:
      #   stabilizationWindowSeconds: 300
      #   policies:
      #   - type: Pods
      #     value: 2
      #     periodSeconds: 60

    autoscalingTemplate: []
    keda:
      enabled: false
      pollingInterval: "30"   # check 30sec periodically for metrics data
      cooldownPeriod: "300"   # once the load decreased, it will wait for 5 min and downscale
      minReplicaCount: "1"    # should be >= replicaCount specified in values.yaml
      maxReplicaCount: "5"
      triggers:
        - type: memory
          metadata:
            type: Utilization
            value: "80"   # hpa make sure average Utilization <=80 by adding new pods
        - type: cpu
          metadata:
            type: Utilization
            value: "80"   # hpa make sure average Utlization <=80 by adding new pods

  # -- Configurations for OtelCollector
  # @default -- See `values.yaml` for defaults
  config:
    receivers:
      otlp/spanmetrics:
        protocols:
          grpc:
            endpoint: localhost:12345
      otlp:
        protocols:
          grpc:
            endpoint: 0.0.0.0:4317
          http:
            endpoint: 0.0.0.0:4318
      jaeger:
        protocols:
          grpc:
            endpoint: 0.0.0.0:14250
          thrift_http:
            endpoint: 0.0.0.0:14268
          # Uncomment to enable thift_company receiver.
          # You will also have set set enable it in `otelCollector.ports
          # thrift_compact:
          #   endpoint: 0.0.0.0:6831
      hostmetrics:
        collection_interval: 30s
        scrapers:
          cpu: {}
          load: {}
          memory: {}
          disk: {}
          filesystem: {}
          network: {}
      prometheus:
        config:
          global:
            scrape_interval: 30s
          scrape_configs:
            - job_name: otel-collector
              static_configs:
              - targets:
                - ${MY_POD_IP}:8888
    processors:
      batch:
        send_batch_size: 1000
        timeout: 10s
      # Ref: https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/processor/resourcedetectionprocessor/README.md
      resourcedetection:
        detectors: [env, system]  # Include ec2/eks for AWS, gce/gke for GCP and azure/aks for Azure
        # Using OTEL_RESOURCE_ATTRIBUTES envvar, env detector adds custom labels
        timeout: 2s
        system:
          hostname_sources: [os]  # Alternatively, use [dns,os] for setting FQDN as host.name and os as fallback
      signozspanmetrics/prometheus:
        metrics_exporter: prometheus
        latency_histogram_buckets:
          [
            100us,
            1ms,
            2ms,
            6ms,
            10ms,
            50ms,
            100ms,
            250ms,
            500ms,
            1000ms,
            1400ms,
            2000ms,
            5s,
            10s,
            20s,
            40s,
            60s,
          ]
        dimensions_cache_size: 10000
        dimensions:
          - name: service.namespace
            default: default
          - name: deployment.environment
            default: default
      # memory_limiter:
      #   # 80% of maximum memory up to 2G
      #   limit_mib: 1500
      #   # 25% of limit up to 2G
      #   spike_limit_mib: 512
      #   check_interval: 5s
      #
      #   # 50% of the maximum memory
      #   limit_percentage: 50
      #   # 20% of max memory usage spike expected
      #   spike_limit_percentage: 20
    extensions:
      health_check:
        endpoint: 0.0.0.0:13133
      zpages:
        endpoint: localhost:55679
      pprof:
        endpoint: localhost:1777
    exporters:
      clickhousetraces:
        datasource: tcp://${CLICKHOUSE_HOST}:${CLICKHOUSE_PORT}/?database=${CLICKHOUSE_TRACE_DATABASE}&username=${CLICKHOUSE_USER}&password=${CLICKHOUSE_PASSWORD}
      clickhousemetricswrite:
        endpoint: tcp://${CLICKHOUSE_HOST}:${CLICKHOUSE_PORT}/?database=${CLICKHOUSE_DATABASE}&username=${CLICKHOUSE_USER}&password=${CLICKHOUSE_PASSWORD}
        resource_to_telemetry_conversion:
          enabled: true
      clickhouselogsexporter:
        dsn: tcp://${CLICKHOUSE_HOST}:${CLICKHOUSE_PORT}/?username=${CLICKHOUSE_USER}&password=${CLICKHOUSE_PASSWORD}
        timeout: 10s
        sending_queue:
          queue_size: 100
        retry_on_failure:
          enabled: true
          initial_interval: 5s
          max_interval: 30s
          max_elapsed_time: 300s
      prometheus:
        endpoint: 0.0.0.0:8889
    service:
      telemetry:
        metrics:
          address: 0.0.0.0:8888
      extensions: [health_check, zpages]
      pipelines:
        traces:
          receivers: [jaeger, otlp]
          processors: [signozspanmetrics/prometheus, batch]
          exporters: [clickhousetraces]
        metrics:
          receivers: [otlp]
          processors: [batch]
          exporters: [clickhousemetricswrite]
        metrics/generic:
          receivers: [hostmetrics, prometheus]
          processors: [resourcedetection, batch]
          exporters: [clickhousemetricswrite]
        metrics/spanmetrics:
          receivers: [otlp/spanmetrics]
          exporters: [prometheus]
        logs:
          receivers: [otlp]
          processors: [batch]
          exporters: [clickhouselogsexporter]

# Default values for OtelCollectorMetrics
otelCollectorMetrics:
  name: "otel-collector-metrics"
  image:
    registry: docker.io
    repository: signoz/signoz-otel-collector
    tag: 0.55.1
    pullPolicy: Always
  imagePullSecrets: []

  # OpenTelemetry Collector executable
  command:
    # -- OtelCollectorMetrics command name
    name: /signoz-collector
    # -- OtelCollectorMetrics command extra arguments
    extraArgs: []

  configMap:
    # -- Specifies whether a configMap should be created (true by default)
    create: true

  # OtelCollectorMetrics service
  service:
    # -- Annotations to use by service associated to OtelCollectorMetrics
    annotations: {}
    # -- Service Type: LoadBalancer (allows external access) or NodePort (more secure, no extra cost)
    type: ClusterIP

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name:

  # -- OtelColectorMetrics Deployment annotation.
  annotations: {}
  # -- OtelColectorMetrics pod(s) annotation.
  podAnnotations:
    signoz.io/scrape: 'true'
    signoz.io/port: '8888'
    signoz.io/path: /metrics

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  minReadySeconds: 5
  progressDeadlineSeconds: 120
  replicaCount: 1
  initContainers:
    init:
      enabled: true
      image:
        registry: docker.io
        repository: busybox
        tag: 1.35
        pullPolicy: IfNotPresent
      command:
        delay: 5
        endpoint: /ping
        waitMessage: "waiting for clickhouseDB"
        doneMessage: "clickhouse ready, starting otel collector metrics now"

  # Configuration for ports
  ports:
    metrics:
      # -- Whether to enable service port for internal metrics
      enabled: false
      # -- Container port for internal metrics
      containerPort: 8888
      # -- Service port for internal metrics
      servicePort: 8888
      # -- Protocol to use for internal metrics
      protocol: TCP
    zpages:
      # -- Whether to enable service port for ZPages
      enabled: false
      # -- Container port for Zpages
      containerPort: 55679
      # -- Service port for Zpages
      servicePort: 55679
      # -- Protocol to use for Zpages
      protocol: TCP
    health-check:
      # -- Whether to enable service port for health check
      enabled: true
      # -- Container port for health check
      containerPort: 13133
      # -- Service port for health check
      servicePort: 13133
      # -- Protocol to use for health check
      protocol: TCP
    pprof:
      # -- Whether to enable service port for pprof
      enabled: false
      # -- Container port for pprof
      containerPort: 1777
      # -- Service port for pprof
      servicePort: 1777
      # -- Protocol to use for pprof
      protocol: TCP


  ## Configure liveness and readiness probes.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes
  ##
  livenessProbe:
    enabled: false
    port: 13133
    path: /
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 6
    successThreshold: 1
  readinessProbe:
    enabled: false
    port: 13133
    path: /
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 6
    successThreshold: 1

  ## Custom liveness and readiness probes
  customLivenessProbe: {}
  customReadinessProbe: {}

  ingress:
    # -- Enable ingress for OtelCollectorMetrics
    enabled: false
    # -- Ingress Class Name to be used to identify ingress controllers
    className: ""
    # -- Annotations to OtelCollectorMetrics Ingress
    annotations: {}
      # cert-manager.io/cluster-issuer: letsencrypt-prod
      # nginx.ingress.kubernetes.io/ssl-redirect: "true"
      # nginx.ingress.kubernetes.io/backend-protocol: "GRPC"
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    # -- OtelCollectorMetrics Ingress Host names with their path details
    hosts:
      - host: otelcollector-metrics.domain.com
        paths:
          - path: /
            pathType: ImplementationSpecific
            port: 13133
    # -- OtelCollectorMetrics Ingress TLS
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - otelcollector-metrics.domain.com

  # -- Configure resource requests and limits. Update according to your own use
  # case as these values might be too low for a typical deployment.
  # ref: http://kubernetes.io/docs/user-guide/compute-resources/
  resources:
    requests:
      cpu: 100m
      memory: 100Mi
    # limits:
    #   cpu: 1000m
    #   memory: 2Gi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  # OtelCollectorMetrics RBAC config
  clusterRole:
    # -- Specifies whether a clusterRole should be created
    create: true
    # -- Annotations to add to the clusterRole
    annotations: {}
    # -- The name of the clusterRole to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""
    # -- A set of rules as documented here : https://kubernetes.io/docs/reference/access-authn-authz/rbac/
    rules:
      - apiGroups: [""]
        resources: ["nodes", "nodes/proxy", "services", "endpoints", "pods"]
        verbs: ["get", "list", "watch"]
      - apiGroups: ["extensions"]
        resources: ["ingresses"]
        verbs: ["get", "list", "watch"]
      - nonResourceURLs: ["/metrics"]
        verbs: ["get"]

    # OtelCollectorMetrics clusterRoleBinding
    clusterRoleBinding:
      # -- Annotations to add to the clusterRoleBinding
      annotations: {}
      # -- The name of the clusterRoleBinding to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""

  # -- Configurations for OtelCollectorMetrics
  # @default -- See `values.yaml` for defaults
  config:
    receivers:
      # prometheus scrape config
      prometheus:
        config:
          scrape_configs:
            # otel-collector-metrics internal metrics
            - job_name: "otel-collector-metrics"
              scrape_interval: 60s
              static_configs:
                - targets:
                  - ${MY_POD_IP}:8888
            # generic prometheus metrics scraper (scrapped when pod annotations are set)
            - job_name: "generic-collector"
              scrape_interval: 60s
              kubernetes_sd_configs:
                - role: pod
              relabel_configs:
                - source_labels:
                    [__meta_kubernetes_pod_annotation_signoz_io_scrape]
                  action: keep
                  regex: true
                - source_labels:
                    [__meta_kubernetes_pod_annotation_signoz_io_path]
                  action: replace
                  target_label: __metrics_path__
                  regex: (.+)
                - source_labels:
                    [
                      __meta_kubernetes_pod_ip,
                      __meta_kubernetes_pod_annotation_signoz_io_port,
                    ]
                  action: replace
                  separator: ":"
                  target_label: __address__
                - action: labelmap
                  regex: __meta_kubernetes_pod_label_(.+)
                - source_labels: [__meta_kubernetes_namespace]
                  action: replace
                  target_label: k8s_namespace
                - source_labels: [__meta_kubernetes_pod_name]
                  action: replace
                  target_label: k8s_pod
    processors:
      batch:
        send_batch_size: 1000
        timeout: 10s
      # -- Memory Limiter processor
      # If set to null, will be overridden with values based on k8s resource limits.
      memory_limiter: null
      # memory_limiter:
      #   # 80% of maximum memory up to 2G
      #   limit_mib: 1500
      #   # 25% of limit up to 2G
      #   spike_limit_mib: 512
      #   check_interval: 5s
      #
      #   # 50% of the maximum memory
      #   limit_percentage: 50
      #   # 20% of max memory usage spike expected
      #   spike_limit_percentage: 20
    extensions:
      health_check:
        endpoint: 0.0.0.0:13133
      zpages:
        endpoint: localhost:55679
      pprof:
        endpoint: localhost:1777
    exporters:
      clickhousemetricswrite:
        endpoint: tcp://${CLICKHOUSE_HOST}:${CLICKHOUSE_PORT}/?database=${CLICKHOUSE_DATABASE}&username=${CLICKHOUSE_USER}&password=${CLICKHOUSE_PASSWORD}
    service:
      telemetry:
        metrics:
          address: 0.0.0.0:8888
      extensions: [health_check, zpages, pprof]
      pipelines:
        metrics:
          receivers: [prometheus]
          processors: [batch]
          exporters: [clickhousemetricswrite]

# Default values for k8s-infra.
# For complete list of configurations, check `values.yaml` of `k8s-infra` chart.
# @ignored
k8s-infra:
  # -- Whether to enable K8s infra monitoring
  enabled: true

  # -- Endpoint/IP Address of the SigNoz or any other OpenTelemetry backend.
  # Set it to `ingest.signoz.io:4317` for SigNoz SaaS.
  #
  # If set to null and the chart is installed as dependency, it will attempt
  # to autogenerate the endpoint of SigNoz OtelCollector.
  otelCollectorEndpoint: null

  # -- Whether the OTLP endpoint is insecure.
  # Set this to false, in case of secure OTLP endpoint.
  otelInsecure: true

  # -- API key of SigNoz SaaS
  signozApiKey: ""

  # -- Kubernetes cluster domain used when k8s-infra component installed in different namespace
  clusterDomain: cluster.local

  # -- Which namespace to install k8s-infra components.
  # By default installed to the namespace same as the chart.
  namespace: ""

  # Default values for OtelAgent
  otelAgent:
    name: "otel-agent"
    image:
      registry: docker.io
      repository: otel/opentelemetry-collector-contrib
      tag: 0.55.0
      pullPolicy: IfNotPresent
    imagePullSecrets: []

    # OpenTelemetry Collector executable
    command:
      # -- OtelAgent command name
      name: /otelcol-contrib
      # -- OtelAgent command extra arguments
      extraArgs: []

    configMap:
      # -- Specifies whether a configMap should be created (true by default)
      create: true

    # OtelAgent service
    service:
      # -- Annotations to use by service associated to OtelAgent
      annotations: {}
      # -- Service Type: LoadBalancer (allows external access) or NodePort (more secure, no extra cost)
      type: ClusterIP

    # -- Configure resource requests and limits. Update according to your own use
    # case as these values might not be suitable for your workload.
    # ref: http://kubernetes.io/docs/user-guide/compute-resources/
    # @default -- See `values.yaml` for defaults
    resources:
      requests:
        cpu: 100m
        memory: 100Mi
      # limits:
      #   cpu: 1000m
      #   memory: 1Gi

  # Default values for OtelDeployment
  otelDeployment:
    name: "otel-deployment"
    image:
      registry: docker.io
      repository: otel/opentelemetry-collector-contrib
      tag: 0.55.0
      pullPolicy: IfNotPresent
    imagePullSecrets: []

    # OpenTelemetry Collector executable
    command:
      # -- OtelDeployment command name
      name: /otelcol-contrib
      # -- OtelDeployment command extra arguments
      extraArgs: []

    configMap:
      # -- Specifies whether a configMap should be created (true by default)
      create: true

    # OtelDeployment service
    service:
      # -- Annotations to use by service associated to OtelDeployment
      annotations: {}
      # -- Service Type: LoadBalancer (allows external access) or NodePort (more secure, no extra cost)
      type: ClusterIP

    # -- Configure resource requests and limits. Update according to your own use
    # case as these values might not be suitable for your workload.
    # ref: http://kubernetes.io/docs/user-guide/compute-resources/
    # @default -- See `values.yaml` for defaults
    resources:
      requests:
        cpu: 100m
        memory: 100Mi
      # limits:
      #   cpu: 1000m
      #   memory: 1Gi
